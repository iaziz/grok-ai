I'll create a Vim plugin inspired by `vim-ai` that integrates with Grok (via xAI's API) for text completion, editing, and interactive chat. The plugin will:

- Support commands for text completion (`:GrokComplete`), editing (`:GrokEdit`), and chat (`:GrokChat`).
- Use an API key for authentication, stored securely in a Vim variable.
- Allow users to select text in visual mode for context-aware API calls.
- Display responses in a new buffer or replace selected text.
- Be compatible with Vim and Neovim, using Python for HTTP requests.

Since xAI's API specifics (endpoint, request format) aren't fully public, I'll use a placeholder endpoint and generic JSON structure, which you can adapt once you have API access. The plugin assumes the API requires a Bearer token and accepts a `prompt` field, returning a `response` field.

```vim
" File: grok.vim
" Description: Vim plugin for AI-powered text completion, editing, and chat with Grok
" Author: Grok
" Version: 1.0

if exists('g:loaded_grok') || !has('python3')
  finish
endif
let g:loaded_grok = 1

" Default API endpoint (replace with xAI's actual endpoint)
if !exists('g:grok_api_endpoint')
  let g:grok_api_endpoint = 'https://api.x.ai/v1/grok'
endif

" Store API key (set via :SetGrokApiKey command)
if !exists('g:grok_api_key')
  let g:grok_api_key = ''
endif

" Command to set API key
command! -nargs=1 SetGrokApiKey let g:grok_api_key = <q-args>

" Function to get visually selected text
function! s:GetVisualSelection()
  let [line_start, col_start] = getpos("'<")[1:2]
  let [line_end, col_end] = getpos("'>")[1:2]
  let lines = getline(line_start, line_end)
  if len(lines) == 0
    return ''
  endif
  let lines[-1] = lines[-1][:col_end - (&selection == 'inclusive' ? 1 : 2)]
  let lines[0] = lines[0][col_start - 1:]
  return join(lines, "\n")
endfunction

" Function to create or switch to chat buffer
function! s:OpenChatBuffer()
  if bufexists('GrokChat')
    execute 'buffer GrokChat'
  else
    execute 'new GrokChat'
    setlocal buftype=nofile
    setlocal bufhidden=hide
    setlocal noswapfile
    setlocal filetype=markdown
  endif
endfunction

" Function to call Grok API
function! s:CallGrokApi(mode, prompt, selected_text) range
  if empty(g:grok_api_key)
    echohl ErrorMsg
    echom "Grok API key not set. Use :SetGrokApiKey <your-key>"
    echohl None
    return
  endif

  let prompt = a:prompt
  if empty(prompt) && empty(a:selected_text)
    echohl WarningMsg
    echom "No prompt or selected text provided"
    echohl None
    return
  endif

  " Start Python block
python3 << EOF
import vim
import json
import http.client
import urllib.parse

def call_grok_api():
    try:
        # Get variables from Vim
        endpoint = vim.eval('g:grok_api_endpoint')
        api_key = vim.eval('g:grok_api_key')
        mode = vim.eval('a:mode')
        prompt = vim.eval('prompt')
        selected_text = vim.eval('a:selected_text')

        # Parse URL
        parsed_url = urllib.parse.urlparse(endpoint)
        conn = http.client.HTTPSConnection(parsed_url.netloc)

        # Prepare request
        headers = {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        }
        body = json.dumps({
            'prompt': prompt,
            'context': selected_text if selected_text else '',
            'mode': mode  # complete, edit, or chat
        })

        # Send request
        conn.request('POST', parsed_url.path, body, headers)
        response = conn.getresponse()
        response_data = response.read().decode()

        if response.status != 200:
            vim.command('echohl ErrorMsg')
            vim.command(f'echom "Grok API request failed: {response.status}"')
            vim.command('echohl None')
            conn.close()
            return

        # Parse response
        try:
            result = json.loads(response_data).get('response', response_data)
        except json.JSONDecodeError:
            result = response_data

        # Handle response based on mode
        if mode == 'complete' or mode == 'edit':
            if mode == 'edit' and selected_text:
                # Replace selected text
                vim.command('normal! gvd')
                vim.current.buffer.append(result.split('\n'), vim.current.window.cursor[0] - 1)
            else:
                # Append completion
                vim.current.buffer.append(result.split('\n'), vim.current.window.cursor[0])
        elif mode == 'chat':
            # Display in chat buffer
            vim.command('call s:OpenChatBuffer()')
            vim.current.buffer.append([f"Prompt: {prompt}", ""] + result.split('\n') + ["---", ""])
            vim.command('normal! G')

        conn.close()

    except Exception as e:
        vim.command('echohl ErrorMsg')
        vim.command(f'echom "Error: {str(e)}"')
        vim.command('echohl None')

call_grok_api()
EOF
endfunction

" Commands for Grok interactions
command! -nargs=? -range GrokComplete call s:CallGrokApi('complete', <q-args>, s:GetVisualSelection())
command! -nargs=? -range GrokEdit call s:CallGrokApi('edit', <q-args>, s:GetVisualSelection())
command! -nargs=? -range GrokChat call s:CallGrokApi('chat', <q-args>, s:GetVisualSelection())

" Default mappings
vnoremap <silent> <Leader>gc :GrokComplete<CR>
vnoremap <silent> <Leader>ge :GrokEdit<CR>
nnoremap <silent> <Leader>gt :GrokChat<CR>

" Instructions for user
echom "Grok Plugin loaded. Set key with :SetGrokApiKey <key>. Use <Leader>gc (complete), <Leader>ge (edit), <Leader>gt (chat)"
```

### How to Use the Plugin

1. **Install the Plugin**:
   - Save the code in `~/.vim/plugged/grok/plugin/grok.vim` (or use a plugin manager like Vim-Plug: `Plug 'your-repo/grok'`).
   - Ensure Vim has Python 3 support (`:echo has('python3')` should return `1`).

2. **Configure the API**:
   - Obtain an API key from xAI (visit https://x.ai/api for details).
   - Set the API key in Vim:
     ```
     :SetGrokApiKey your-api-key-here
     ```
   - Update the endpoint in your `.vimrc` if needed:
     ```vim
     let g:grok_api_endpoint = 'https://api.x.ai/v1/grok'
     ```

3. **Usage**:
   - **Text Completion (`:GrokComplete`)**:
     - Select text in visual mode (optional) for context.
     - Run `:GrokComplete <prompt>` or press `<Leader>gc` (default `\gc`).
     - The response appends below the cursor or current line.
   - **Text Editing (`:GrokEdit`)**:
     - Select text in visual mode.
     - Run `:GrokEdit <prompt>` (e.g., `:GrokEdit fix grammar`) or press `<Leader>ge`.
     - The selected text is replaced with the API response.
   - **Chat (`:GrokChat`)**:
     - Run `:GrokChat <prompt>` or press `<Leader>gt`.
     - Responses appear in a `GrokChat` buffer (markdown filetype) with prompt history.
   - Example:
     ```
     :GrokComplete Write a Python function to reverse a string
     :GrokEdit Refactor this code to be more concise
     :GrokChat Explain how Vim's undo tree works
     ```

4. **Customization**:
   - Change mappings in your `.vimrc`:
     ```vim
     vnoremap <C-g>c :GrokComplete<CR>
     vnoremap <C-g>e :GrokEdit<CR>
     nnoremap <C-g>t :GrokChat<CR>
     ```
   - Modify the Python code to match xAI's API format (e.g., adjust `body` or response parsing).
   - Add custom roles (e.g., `:GrokEdit /grammar`) by extending the plugin with a role configuration file, similar to `vim-ai`.[](https://github.com/madox2/vim-ai)

### Notes
- The plugin is modeled after `vim-ai`, supporting similar commands (`:AI`, `:AIEdit`, `:AIChat`) but tailored for Grok.[](https://github.com/madox2/vim-ai)[](https://www.vim.org/scripts/script.php?script_id=6048)
- The API endpoint and request format are placeholders. Update them based on xAI's API documentation (https://x.ai/api).
- The plugin requires an internet connection and Python 3. It sends only the selected text and prompt to the API, ensuring minimal data sharing.[](https://github.com/madox2/vim-ai)
- For local models or open-source alternatives, consider using an OpenAI-compatible proxy like OpenRouter, as suggested in `vim-ai` documentation.[](https://github.com/madox2/vim-ai)
- Error handling covers missing API keys, empty prompts, and API failures.
- The chat buffer uses markdown for readability, with Treesitter support for syntax highlighting if installed.[](https://www.reddit.com/r/neovim/comments/15zm24u/have_any_of_the_ai_plugins_stuck_with_you/)

If you have access to xAI's API specifics or want to add features (e.g., custom roles, streaming responses), let me know, and I can refine the plugin further!